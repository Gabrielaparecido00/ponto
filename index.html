<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Registro de Ponto</title>

<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">

<style>
  *{ box-sizing:border-box; }
  body { font-family:'Montserrat', Arial, sans-serif; background:#f0f0f0; padding:16px; }
  .container{
    max-width:520px; margin:auto; background:#fff; padding:18px; border-radius:12px;
    box-shadow:0 2px 10px rgba(0,0,0,0.10);
  }
  .logo{ width:220px; display:block; margin:0 auto 14px; max-width:90vw; height:auto; }
  h2{ text-align:center; margin:8px 0 14px; }
  input, button, select{
    width:100%; padding:10px; border-radius:10px; border:1px solid #ccc; margin-bottom:10px;
    font-family:inherit;
  }
  button{ background:#4CAF50; color:#fff; font-weight:700; cursor:pointer; border:none; }
  button:hover{ background:#45a049; }
  button.secondary{ background:#1f6feb; }
  button.secondary:hover{ background:#1a5dd6; }
  button:disabled{ opacity:.6; cursor:not-allowed; }
  canvas{ width:100%; border:1px solid #ccc; border-radius:10px; }
  #timestamp{ text-align:center; margin-top:10px; font-weight:700; }
  #nomeMostrado{ font-weight:700; text-align:center; margin:8px 0 6px; }
  #horarioMostrado{ text-align:center; margin:0 0 10px; font-size:12px; color:#444; }
  .smallInfo{ text-align:center; font-size:12px; color:#666; margin:8px 0 0; }
  .phaseBox{
    background:#f7f7f7; border:1px solid #e6e6e6; border-radius:10px;
    padding:10px; margin:10px 0;
  }
  .phaseTitle{ font-weight:700; margin-bottom:6px; text-align:center; }
  .phaseLine{ font-size:12px; color:#444; text-align:center; }
  .blocked{
    background:#fff0f0;
    border:1px solid #f2b8b5;
    color:#8a0000;
    padding:10px;
    border-radius:10px;
    font-size:12px;
    text-align:center;
    margin:10px 0;
    display:none;
    white-space:pre-line;
  }
  .footer{ text-align:center; margin-top:16px; font-size:12px; color:#666; }
  #camPreview{ display:none; width:1px; height:1px; opacity:0; pointer-events:none; }

  /* ===== Modal FT ===== */
  .overlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,0.45);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:9999;
    padding:12px;
  }
  .modal{
    background:#fff;
    width:min(520px, 96vw);
    border-radius:12px;
    padding:14px;
    box-shadow:0 10px 30px rgba(0,0,0,0.22);
    text-align:left;
  }
  .modal h3{ margin:0 0 10px; }
  .modal p{ margin:0 0 10px; font-size:13px; color:#333; }
  .modal .row{
    display:flex; gap:8px; flex-wrap:wrap;
  }
  .modal .row button{
    width:auto; flex:1;
    border-radius:10px;
    padding:10px 12px;
  }
  .btnGhost{ background:#e9ecef; color:#111; }
  .btnGhost:hover{ background:#dfe3e8; }
  .btnPrimary{ background:#1f6feb; }
  .btnPrimary:hover{ background:#1a5dd6; }
  .muted{ color:#666; font-size:12px; }
</style>
</head>

<body>
<div class="container">
  <img src="GW.png" class="logo" />
  <h2>Registro de Ponto</h2>

  <input type="text" id="re" placeholder="Digite seu RE" inputmode="numeric" autocomplete="off">
  <div id="nomeMostrado">Nome: ‚Äî</div>
  <div id="horarioMostrado">Hor√°rio previsto: ‚Äî</div>

  <div class="phaseBox">
    <div class="phaseTitle" id="faseAtual">Fase atual: ‚Äî</div>
    <div class="phaseLine" id="faseHint">Digite seu RE para carregar suas op√ß√µes.</div>
  </div>

  <div id="blockedBox" class="blocked"></div>

  <select id="acaoSelect" disabled>
    <option value="">Selecione a marca√ß√£o...</option>
  </select>

  <video id="camPreview" autoplay playsinline muted></video>

  <canvas id="photo" width="240" height="320"></canvas>
  <button type="button" id="captureBtn">Capturar Foto</button>

  <button type="button" id="registrarBtn" disabled>Registrar</button>
  <button type="button" class="secondary" onclick="window.location.href='meu_ponto.html'">√Årea do colaborador</button>

  <div id="timestamp"></div>
  <div class="smallInfo">‚ö†Ô∏è Registro s√≥ √© permitido dentro de um posto cadastrado (raio).</div>
</div>

<div class="footer">
  Sistema desenvolvido por Gabriel Wandele, todos direitos reservados
</div>

<!-- ===== Modal FT ===== -->
<div class="overlay" id="ftOverlay" onclick="closeFtIfBackdrop(event)">
  <div class="modal" onclick="event.stopPropagation()">
    <h3 id="ftTitle">FT</h3>
    <div id="ftBody"></div>
    <div class="row" style="margin-top:10px;">
      <button class="btnGhost" id="ftCancel">Cancelar</button>
      <button class="btnPrimary" id="ftOk">Confirmar</button>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, addDoc, collection, getDocs, query, where
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyD--zpWLbLg5X82oGTyz6SuPFQV0sd7NWc",
  authDomain: "controle-ponto-f539b.firebaseapp.com",
  projectId: "controle-ponto-f539b",
  storageBucket: "controle-ponto-f539b.appspot.com",
  messagingSenderId: "324716100257",
  appId: "1:324716100257:web:32d49a9ab4916182dd4ee0"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// UI
const reInput = document.getElementById("re");
const nomeMostrado = document.getElementById("nomeMostrado");
const horarioMostrado = document.getElementById("horarioMostrado");
const registrarBtn = document.getElementById("registrarBtn");
const captureBtn = document.getElementById("captureBtn");
const canvas = document.getElementById("photo");
const ctx = canvas.getContext("2d");
const camPreview = document.getElementById("camPreview");

const faseAtualEl = document.getElementById("faseAtual");
const faseHintEl = document.getElementById("faseHint");
const acaoSelect = document.getElementById("acaoSelect");
const blockedBox = document.getElementById("blockedBox");

// Modal FT
const ftOverlay = document.getElementById("ftOverlay");
const ftTitle = document.getElementById("ftTitle");
const ftBody = document.getElementById("ftBody");
const ftCancel = document.getElementById("ftCancel");
const ftOk = document.getElementById("ftOk");

function closeFt(){ ftOverlay.style.display="none"; ftBody.innerHTML=""; ftCancel.onclick=null; ftOk.onclick=null; }
function closeFtIfBackdrop(e){ if (e.target===ftOverlay) closeFt(); }
window.closeFtIfBackdrop = closeFtIfBackdrop;

// estado
let colaborador = null;
let stream = null;
let clickLock = false;
let hasPhoto = false;

// cache supervisores
let cacheSupervisores = [];

async function carregarSupervisoresSafe(){
  try{
    const snap = await getDocs(collection(db,"supervisores"));
    cacheSupervisores = snap.docs
      .map(d => ({ id:d.id, ...(d.data()||{}) }))
      .map(x => ({ id:x.id, nome: String(x.nome||"").trim() }))
      .filter(x => !!x.nome)
      .sort((a,b)=>a.nome.localeCompare(b.nome));
  }catch{
    cacheSupervisores = [];
  }
}
carregarSupervisoresSafe();

function resetPhoto(){
  hasPhoto = false;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function showBlocked(msg){
  blockedBox.style.display = msg ? "block" : "none";
  blockedBox.textContent = msg || "";
}

function setRegisterEnabled(){
  const temAcoes = acaoSelect && acaoSelect.options.length > 1;
  const temAcaoSelecionada = !!acaoSelect.value;
  registrarBtn.disabled = !(colaborador && temAcoes && temAcaoSelecionada && hasPhoto);
}

function setInputsEnabled(enabled){
  const temAcoes = acaoSelect.options.length > 1;
  acaoSelect.disabled = !enabled || !temAcoes;
  captureBtn.disabled = !enabled;

  if (!enabled){
    registrarBtn.disabled = true;
  } else {
    setRegisterEnabled();
  }
}

// rel√≥gio
setInterval(() => {
  document.getElementById("timestamp").innerText = "Data/Hora: " + new Date().toLocaleString("pt-BR");
}, 1000);

// c√¢mera
async function iniciarCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" }
    });
    camPreview.srcObject = stream;
  }catch{
    alert("Erro ao acessar c√¢mera");
  }
}
iniciarCamera();

window.addEventListener("beforeunload", () => {
  try{
    if (stream){
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
  }catch{}
});

// captura
captureBtn.addEventListener("click", async () => {
  if (!stream) return alert("C√¢mera n√£o iniciada");

  const cw = canvas.width, ch = canvas.height;

  function drawCover(sourceW, sourceH, drawFn){
    const scale = Math.max(cw / sourceW, ch / sourceH);
    const sw = cw / scale;
    const sh = ch / scale;
    const sx = (sourceW - sw) / 2;
    const sy = (sourceH - sh) / 2;

    ctx.clearRect(0, 0, cw, ch);
    drawFn(sx, sy, sw, sh);
    hasPhoto = true;
    setRegisterEnabled();
  }

  try{
    const track = stream.getVideoTracks()[0];
    if (window.ImageCapture && track){
      const imageCapture = new ImageCapture(track);
      const bitmap = await imageCapture.grabFrame();
      drawCover(bitmap.width, bitmap.height, (sx,sy,sw,sh) => {
        ctx.drawImage(bitmap, sx, sy, sw, sh, 0, 0, cw, ch);
      });
      return;
    }
  }catch{}

  try{
    const v = camPreview;
    if (!v || v.readyState < 2) return alert("C√¢mera ainda carregando, tente novamente.");
    const vw = v.videoWidth, vh = v.videoHeight;
    if (!vw || !vh) return alert("N√£o foi poss√≠vel capturar o frame da c√¢mera.");

    drawCover(vw, vh, (sx,sy,sw,sh) => {
      ctx.drawImage(v, sx, sy, sw, sh, 0, 0, cw, ch);
    });
  }catch{
    alert("Erro ao capturar foto");
  }
});

// helpers
function pad2(n){ return String(n).padStart(2,"0"); }
function todayYmd(){
  const d = new Date();
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}
function brDateFromYmd(ymd){
  if (!ymd) return "";
  const [y,m,d] = ymd.split("-");
  if (!y || !m || !d) return ymd;
  return `${d}/${m}/${y}`;
}
function addDaysYmd(ymd, days){
  const [y,m,d] = (ymd||"").split("-").map(Number);
  const dt = new Date(y, (m||1)-1, d||1, 12, 0, 0);
  dt.setDate(dt.getDate() + (days||0));
  return dt.toISOString().slice(0,10);
}
function setDateKeepingTime(iso, ymd){
  // troca s√≥ a data do ISO, preservando hora/min/seg
  const d = new Date(iso);
  if (isNaN(d)) return iso;
  const hh = pad2(d.getHours());
  const mm = pad2(d.getMinutes());
  const ss = pad2(d.getSeconds());
  // usa hor√°rio local no ISO (mesma forma do seu sistema atual: toISOString)
  // vamos criar uma data local e converter para ISO
  const [Y,M,D] = ymd.split("-").map(Number);
  const local = new Date(Y, M-1, D, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
  return local.toISOString();
}

function isFolgaByEscala(dateObj, escala){
  const dow = dateObj.getDay();
  const e = (escala || "5x2").toLowerCase();
  if (e === "5x2") return (dow === 0 || dow === 6);
  if (e === "6x1") return (dow === 0);
  return false;
}
function isDiaTrabalho(dateObj, escala){
  return !isFolgaByEscala(dateObj, escala);
}

// locais (cache)
let cacheLocais = [];

function haversineMeters(lat1, lon1, lat2, lon2){
  const R=6371000; const toRad=x=>x*Math.PI/180;
  const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
  const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

async function carregarLocaisSafe(){
  try{
    const snap = await getDocs(collection(db,"locais"));
    cacheLocais = snap.docs
      .map(d => ({ id:d.id, ...d.data() }))
      .filter(l => Number.isFinite(l.lat) && Number.isFinite(l.lng) && Number.isFinite(l.raio));
    return { ok:true, total: cacheLocais.length };
  }catch{
    cacheLocais = [];
    return { ok:false };
  }
}
carregarLocaisSafe();

async function getLocationStrict(){
  const resLocais = await carregarLocaisSafe();
  if (!resLocais.ok){
    return { ok:false, message:"N√£o foi poss√≠vel validar o posto no momento. Tente novamente." };
  }
  if (!cacheLocais.length){
    return { ok:false, message:"Nenhum local (posto) est√° cadastrado no sistema. Registro BLOQUEADO. Procure o administrador." };
  }

  let pos;
  try{
    pos = await new Promise((res, rej) =>
      navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy:true, timeout:12000 })
    );
  }catch{
    return { ok:false, message:"Localiza√ß√£o √© obrigat√≥ria. Ative o GPS e permita o acesso √† localiza√ß√£o." };
  }

  const lat = pos.coords.latitude;
  const lng = pos.coords.longitude;
  if (!Number.isFinite(lat) || !Number.isFinite(lng)){
    return { ok:false, message:"N√£o foi poss√≠vel obter coordenadas v√°lidas." };
  }

  let best = null;
  for (const l of cacheLocais){
    const d = haversineMeters(lat, lng, l.lat, l.lng);
    if (d <= l.raio){
      if (!best || d < best.d) best = { nome:l.nome, d };
    }
  }

  if (!best){
    let nearest = null;
    for (const l of cacheLocais){
      const d = haversineMeters(lat, lng, l.lat, l.lng);
      if (!nearest || d < nearest.d) nearest = { nome:l.nome, d, raio:l.raio };
    }
    const info = nearest
      ? `Posto mais pr√≥ximo: ${nearest.nome}\nDist√¢ncia aprox.: ${Math.round(nearest.d)}m\nRaio do posto: ${Math.round(nearest.raio)}m`
      : "";
    return { ok:false, message:`Fora do posto cadastrado.\n${info}\n\nN√£o √© permitido registrar ponto fora do local.` };
  }

  return { ok:true, locationStr:`${lat},${lng}`, posto:best.nome };
}

// f√©rias
async function carregarAfastamentosDoRe(re){
  const qA = query(collection(db,"afastamentos"), where("re","==",re));
  const snap = await getDocs(qA);
  return snap.docs.map(d => ({ id:d.id, ...(d.data()||{}) }));
}
function isWithinRange(ymd, ini, fim){
  return !!(ymd && ini && fim && ymd >= ini && ymd <= fim);
}
function aplicaNoDia(afast, dateObj, escala){
  const onlyWork = (afast?.aplicarSomenteDiasTrabalho === true);
  if (onlyWork && !isDiaTrabalho(dateObj, escala)) return false;
  return true;
}
async function checarBloqueioFerias(re, escala){
  const hoje = todayYmd();
  const dateObj = new Date();
  const afast = await carregarAfastamentosDoRe(re);
  const ferias = afast.filter(a => (String(a.tipo||"").toLowerCase() === "ferias"));
  for (const f of ferias){
    const ini = String(f.inicio||"").slice(0,10);
    const fim = String(f.fim||"").slice(0,10);
    if (isWithinRange(hoje, ini, fim) && aplicaNoDia(f, dateObj, escala)){
      return { bloqueado:true, ferias:f };
    }
  }
  return { bloqueado:false, ferias:null };
}

// regras / etapas
const TEMPO_MINIMO = 5 * 60 * 1000;

const ETAPAS = {
  ENTRADA: "entrada",
  SAIDA_INTERVALO: "saida_intervalo",
  RETORNO_INTERVALO: "retorno_intervalo",
  SAIDA: "saida",
  ENTRADA_HE: "entrada_he",
  SAIDA_HE: "saida_he"
};

const etapaLabels = {
  [ETAPAS.ENTRADA]: "ENTRADA",
  [ETAPAS.SAIDA_INTERVALO]: "IN√çCIO INTERVALO",
  [ETAPAS.RETORNO_INTERVALO]: "FIM INTERVALO",
  [ETAPAS.SAIDA]: "SA√çDA",
  [ETAPAS.ENTRADA_HE]: "ENTRADA HE",
  [ETAPAS.SAIDA_HE]: "SA√çDA HE"
};

const etapaConfirms = {
  [ETAPAS.ENTRADA]: "Voc√™ est√° entrando no servi√ßo?",
  [ETAPAS.SAIDA_INTERVALO]: "Voc√™ est√° INICIANDO seu intervalo?",
  [ETAPAS.RETORNO_INTERVALO]: "Voc√™ est√° ENCERRANDO seu intervalo (retorno)?",
  [ETAPAS.SAIDA]: "Voc√™ est√° encerrando o expediente?",
  [ETAPAS.ENTRADA_HE]: "Voc√™ est√° iniciando hora extra?",
  [ETAPAS.SAIDA_HE]: "Voc√™ est√° encerrando hora extra?"
};

function toDateAny(ts){
  if (!ts) return null;
  if (ts.toDate) return ts.toDate();
  if (ts instanceof Date) return ts;
  return new Date(ts);
}

function limparForm(){
  reInput.value = "";
  colaborador = null;
  nomeMostrado.innerText = "Nome: ‚Äî";
  horarioMostrado.innerText = "Hor√°rio previsto: ‚Äî";
  faseAtualEl.innerText = "Fase atual: ‚Äî";
  faseHintEl.innerText = "Digite seu RE para carregar suas op√ß√µes.";
  acaoSelect.innerHTML = `<option value="">Selecione a marca√ß√£o...</option>`;
  acaoSelect.disabled = true;
  showBlocked("");
  setInputsEnabled(true);
  resetPhoto();
  setRegisterEnabled();
}

function horarioTxt(c){
  const he = (c?.horaEntrada || "").trim();
  const hs = (c?.horaSaida || "").trim();
  if (he && hs) return `${he}‚Äì${hs}`;
  if (he || hs) return `${he || "‚Äî"}‚Äì${hs || "‚Äî"}`;
  return "‚Äî";
}

async function buscarColaborador(re){
  const ref = doc(db, "colaboradores", re);
  const snap = await getDoc(ref);
  if (!snap.exists()) return null;
  const data = snap.data() || {};
  return {
    re,
    nome: (data.nome || "").trim(),
    ativo: (data.ativo !== false),
    escala: (data.escala || "5x2"),
    horaEntrada: (data.horaEntrada || "").toString().trim(),
    horaSaida: (data.horaSaida || "").toString().trim(),
    dataAdmissao: String(data.dataAdmissao || "").slice(0,10)
  };
}

function pickLastTs(j){
  return (
    toDateAny(j?.saida_he?.ts) ||
    toDateAny(j?.entrada_he?.ts) ||
    toDateAny(j?.saida?.ts) ||
    toDateAny(j?.retorno_intervalo?.ts) ||
    toDateAny(j?.saida_intervalo?.ts) ||
    toDateAny(j?.entrada?.ts)
  );
}

function getEstadoEAcaoPermitida(j){
  if (!j) {
    return {
      fase: "Sem jornada aberta",
      hint: "Voc√™ pode registrar: ENTRADA",
      acoes: [ETAPAS.ENTRADA]
    };
  }

  const temEntrada = !!j?.entrada?.ts;
  const temSaiInt = !!j?.saida_intervalo?.ts;
  const temRetInt = !!j?.retorno_intervalo?.ts;
  const temSaida = !!j?.saida?.ts;
  const temEntHe = !!j?.entrada_he?.ts;
  const temSaiHe = !!j?.saida_he?.ts;

  if (!temEntrada){
    return { fase:"Jornada inv√°lida", hint:"Falta ENTRADA. Procure o admin.", acoes:[ETAPAS.ENTRADA] };
  }

  if (!temSaida){
    if (!temSaiInt && !temRetInt){
      return {
        fase: "Ap√≥s ENTRADA",
        hint: "Escolha: iniciar INTERVALO ou encerrar (SA√çDA).",
        acoes: [ETAPAS.SAIDA_INTERVALO, ETAPAS.SAIDA]
      };
    }
    if (temSaiInt && !temRetInt){
      return {
        fase: "Intervalo em andamento",
        hint: "Voc√™ s√≥ pode registrar: FIM INTERVALO.",
        acoes: [ETAPAS.RETORNO_INTERVALO]
      };
    }
    if (temRetInt){
      return {
        fase: "Ap√≥s intervalo",
        hint: "Voc√™ pode registrar: SA√çDA.",
        acoes: [ETAPAS.SAIDA]
      };
    }
    return { fase:"Estado incomum", hint:"Procure o admin.", acoes:[] };
  }

  if (temSaida && !temEntHe && !temSaiHe){
    return {
      fase: "Expediente encerrado",
      hint: "Opcional: iniciar HORA EXTRA (ENTRADA HE) ou iniciar nova ENTRADA.",
      acoes: [ETAPAS.ENTRADA_HE, ETAPAS.ENTRADA]
    };
  }

  if (temEntHe && !temSaiHe){
    return {
      fase: "Hora extra em andamento",
      hint: "Voc√™ s√≥ pode registrar: SA√çDA HE.",
      acoes: [ETAPAS.SAIDA_HE]
    };
  }

  if (temSaiHe){
    return {
      fase: "Jornada finalizada",
      hint: "Voc√™ pode iniciar uma nova ENTRADA.",
      acoes: [ETAPAS.ENTRADA]
    };
  }

  return { fase:"Estado incomum", hint:"Procure o admin.", acoes:[] };
}

function montarSelectAcoes(acoes){
  const prev = acaoSelect.value;

  acaoSelect.innerHTML = `<option value="">Selecione a marca√ß√£o...</option>`;
  for (const a of acoes){
    const opt = document.createElement("option");
    opt.value = a;
    opt.textContent = etapaLabels[a] || a;
    acaoSelect.appendChild(opt);
  }

  if (prev && acoes.includes(prev)){
    acaoSelect.value = prev;
  } else if (acoes.length === 1){
    acaoSelect.value = acoes[0];
  }

  acaoSelect.disabled = acoes.length === 0;
  setRegisterEnabled();
}

async function obterJornadaAtivaDoRe(re){
  const q = query(collection(db, "jornadas"), where("re", "==", re));
  const snap = await getDocs(q);
  const jornadas = snap.docs.map(d => ({ id:d.id, ...d.data() }));

  jornadas.sort((a,b) => {
    const ta = toDateAny(a.updatedAt) || toDateAny(a.entrada?.ts) || new Date(0);
    const tb = toDateAny(b.updatedAt) || toDateAny(b.entrada?.ts) || new Date(0);
    return tb - ta;
  });

  for (const j of jornadas){
    const temSaida = !!j?.saida?.ts;
    const temEntHe = !!j?.entrada_he?.ts;
    const temSaiHe = !!j?.saida_he?.ts;

    if (!temSaida) return j;
    if (temEntHe && !temSaiHe) return j;
    if (temSaida && !temEntHe && !temSaiHe) return j;
  }

  return null;
}

// ====== DUPLICIDADE DE ENTRADA NO DIA ======
async function existeEntradaNoDia(re, ymdKey){
  try{
    const qJ = query(collection(db, "jornadas"), where("re", "==", re));
    const snap = await getDocs(qJ);
    const list = snap.docs.map(d => d.data() || {});
    return list.some(j => String(j?.entrada?.ts || "").slice(0,10) === ymdKey);
  }catch{
    // em caso de falha, melhor N√ÉO liberar 2 entradas sem checar
    return true;
  }
}

// ====== MODAL FT (3 passos) ======
function askFtFlow({diaOriginalYmd}){
  return new Promise(async (resolve) => {
    await carregarSupervisoresSafe();

    // passo 1
    ftTitle.textContent = "Folga Trabalhada (FT)";
    ftBody.innerHTML = `
      <p>J√° existe uma <b>ENTRADA</b> registrada em <b>${brDateFromYmd(diaOriginalYmd)}</b>.</p>
      <p>Voc√™ quer registrar uma <b>FT</b> (Folga Trabalhada)?</p>
      <p class="muted">Se SIM, voc√™ responder√° motivo + supervisor, e o sistema vai registrar como <b>dia seguinte</b> para an√°lise interna.</p>
    `;
    ftOverlay.style.display = "flex";

    ftCancel.textContent = "N√£o";
    ftOk.textContent = "Sim";

    ftCancel.onclick = () => { closeFt(); resolve({ ok:false }); };
    ftOk.onclick = () => {
      // passo 2 (motivo)
      ftTitle.textContent = "FT ‚Äî Motivo";
      ftBody.innerHTML = `
        <p>Informe o <b>motivo</b> da FT:</p>
        <input id="ftMotivo" placeholder="Ex: cobertura / solicita√ß√£o do posto / necessidade operacional">
        <div class="muted" style="margin-top:6px;">Isso n√£o √© autoriza√ß√£o; √© s√≥ barreira para n√£o mentir.</div>
      `;
      ftCancel.textContent = "Voltar";
      ftOk.textContent = "Continuar";

      ftCancel.onclick = () => {
        // volta ao passo 1
        closeFt();
        resolve(askFtFlow({diaOriginalYmd}));
      };

      ftOk.onclick = () => {
        const motivo = (document.getElementById("ftMotivo").value || "").trim();
        if (!motivo) return alert("Informe o motivo da FT.");

        // passo 3 (supervisor)
        ftTitle.textContent = "FT ‚Äî Supervisor";
        const opts = (cacheSupervisores||[])
          .map(s => `<option value="${String(s.nome).replaceAll('"','&quot;')}">${s.nome}</option>`)
          .join("");
        ftBody.innerHTML = `
          <p>Selecione o <b>supervisor</b> respons√°vel por autorizar:</p>
          <select id="ftSupervisor">
            <option value="">Selecione...</option>
            ${opts}
          </select>
          <div class="muted" style="margin-top:6px;">O admin n√£o autoriza nada aqui; fica pendente s√≥ para visualiza√ß√£o.</div>
        `;

        ftCancel.textContent = "Voltar";
        ftOk.textContent = "Confirmar";

        ftCancel.onclick = () => {
          // volta para motivo
          closeFt();
          resolve(askFtFlow({diaOriginalYmd}));
        };

        ftOk.onclick = () => {
          const supervisor = (document.getElementById("ftSupervisor").value || "").trim();
          if (!supervisor) return alert("Selecione o supervisor.");

          closeFt();
          resolve({ ok:true, motivo, supervisor });
        };
      };
    };
  });
}

async function atualizarTela(){
  try{
    resetPhoto();
    setRegisterEnabled();

    const re = reInput.value.trim();
    colaborador = null;
    nomeMostrado.innerText = "Nome: ‚Äî";
    horarioMostrado.innerText = "Hor√°rio previsto: ‚Äî";
    faseAtualEl.innerText = "Fase atual: ‚Äî";
    faseHintEl.innerText = "Digite seu RE para carregar suas op√ß√µes.";
    montarSelectAcoes([]);
    showBlocked("");
    setInputsEnabled(true);

    if (!re) return;

    const c = await buscarColaborador(re);
    if (!c || !c.nome){
      nomeMostrado.innerText = "Nome: (RE n√£o cadastrado)";
      setRegisterEnabled();
      return;
    }
    if (!c.ativo){
      nomeMostrado.innerText = `Nome: ${c.nome} (INATIVO)`;
      setInputsEnabled(false);
      setRegisterEnabled();
      return;
    }

    // bloqueio pr√©-admiss√£o
    const adm = (c.dataAdmissao || "").slice(0,10);
    const hoje = todayYmd();
    if (adm && hoje < adm){
      colaborador = c;
      nomeMostrado.innerText = "Nome: " + c.nome;
      horarioMostrado.innerText = "Hor√°rio previsto: " + horarioTxt(c);

      showBlocked(`üö´ BLOQUEADO: Sua admiss√£o √© em ${brDateFromYmd(adm)}.\nRegistro liberado somente a partir desta data.`);
      faseAtualEl.innerText = "Fase atual: PR√â-ADMISS√ÉO";
      faseHintEl.innerText = "Registro n√£o permitido antes da admiss√£o.";
      montarSelectAcoes([]);
      setInputsEnabled(false);
      setRegisterEnabled();
      return;
    }

    colaborador = c;
    nomeMostrado.innerText = "Nome: " + c.nome;
    horarioMostrado.innerText = "Hor√°rio previsto: " + horarioTxt(c);

    // f√©rias
    const chk = await checarBloqueioFerias(re, c.escala);
    if (chk.bloqueado){
      const f = chk.ferias;
      const ini = String(f.inicio||"").slice(0,10);
      const fim = String(f.fim||"").slice(0,10);
      const motivo = (f.motivo || "").toString().trim();
      showBlocked(`üö´ BLOQUEADO: Voc√™ est√° de F√âRIAS hoje.\nPer√≠odo: ${brDateFromYmd(ini)} at√© ${brDateFromYmd(fim)}${motivo ? "\nMotivo: "+motivo : ""}`);
      faseAtualEl.innerText = "Fase atual: F√âRIAS";
      faseHintEl.innerText = "Registro n√£o permitido durante f√©rias.";
      montarSelectAcoes([]);
      setInputsEnabled(false);
      setRegisterEnabled();
      return;
    }

    const jornada = await obterJornadaAtivaDoRe(re);
    const st = getEstadoEAcaoPermitida(jornada);

    faseAtualEl.innerText = "Fase atual: " + st.fase;
    faseHintEl.innerText = st.hint;
    montarSelectAcoes(st.acoes);

    acaoSelect.disabled = (st.acoes.length === 0);
    captureBtn.disabled = false;
    setRegisterEnabled();

  }catch{
    montarSelectAcoes([]);
    setInputsEnabled(false);
    setRegisterEnabled();
    alert("Erro ao carregar dados. Tente novamente.");
  }
}

// listeners
reInput.addEventListener("blur", atualizarTela);
reInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter"){
    e.preventDefault();
    atualizarTela();
  }
});

let tRe = null;
reInput.addEventListener("input", () => {
  clearTimeout(tRe);
  tRe = setTimeout(() => atualizarTela(), 350);
});

acaoSelect.addEventListener("change", () => {
  setRegisterEnabled();
});

// registrar
registrarBtn.addEventListener("click", async () => {
  if (clickLock) return;
  clickLock = true;
  setTimeout(() => clickLock = false, 1200);

  if (!colaborador || acaoSelect.options.length <= 1){
    await atualizarTela();
  }

  const re = reInput.value.trim();
  if (!re) return alert("Digite o RE.");

  if (!colaborador){
    return alert("Colaborador n√£o cadastrado, INATIVO ou bloqueado. Confira o RE.");
  }

  if (!hasPhoto){
    return alert("Voc√™ precisa CAPTURAR A FOTO antes de registrar.");
  }

  // bloqueio pr√©-admiss√£o (dupla checagem)
  const adm = (colaborador.dataAdmissao || "").slice(0,10);
  const hoje = todayYmd();
  if (adm && hoje < adm){
    await atualizarTela();
    return;
  }

  const chk = await checarBloqueioFerias(re, colaborador.escala);
  if (chk.bloqueado){
    await atualizarTela();
    return;
  }

  const acao = acaoSelect.value;
  if (!acao) return alert("Selecione qual marca√ß√£o deseja registrar.");

  const loc = await getLocationStrict();
  if (!loc.ok) return alert(loc.message);
  const location = loc.locationStr;
  const posto = loc.posto || "";

  const foto = canvas.toDataURL("image/jpeg", 0.4);

  const jornadaAtiva = await obterJornadaAtivaDoRe(re);
  const st = getEstadoEAcaoPermitida(jornadaAtiva);
  if (!st.acoes.includes(acao)){
    await atualizarTela();
    return alert("A√ß√£o n√£o permitida na fase atual. Atualizei sua fase; selecione novamente.");
  }

  // confirma√ß√£o padr√£o
  const msg = etapaConfirms[acao] || "Confirmar registro?";
  if (!confirm(msg)) return;

  const now = new Date();
  const nowIso = now.toISOString();

  // anti-duplicidade 5 min
  const lastTs = pickLastTs(jornadaAtiva);
  if (lastTs && (now - lastTs) < TEMPO_MINIMO){
    return alert("Registro duplicado detectado. Aguarde 5 minutos para registrar novamente.");
  }

  // ===== ENTRADA (com regra de 2 entradas/dia + FT) =====
  if (acao === ETAPAS.ENTRADA){
    const jaTemEntradaHoje = await existeEntradaNoDia(re, hoje);

    if (jaTemEntradaHoje){
      // abre FT flow
      const ft = await askFtFlow({ diaOriginalYmd: hoje });
      if (!ft.ok){
        return alert("Opera√ß√£o cancelada. N√£o √© permitido 2 ENTRADAS no mesmo dia sem FT.");
      }

      // cria nova ENTRADA como DIA SEGUINTE
      const diaSeguinte = addDaysYmd(hoje, 1);
      const entradaIsoShift = setDateKeepingTime(nowIso, diaSeguinte);

      // jornada ‚Äúnormal‚Äù, s√≥ que data (entrada.ts) = dia seguinte
      await addDoc(collection(db, "jornadas"), {
        re,
        nome: colaborador.nome,
        status: "aberta",
        entrada: {
          ts: entradaIsoShift,     // üëà chave do dia (dia seguinte)
          tsReal: nowIso,          // üëà real (auditoria)
          foto,
          location,
          posto
        },
        ftMeta: {
          isFT: true,
          diaOriginal: hoje,
          diaRegistrado: diaSeguinte,
          motivo: ft.motivo,
          supervisor: ft.supervisor,
          createdAt: nowIso
        },
        updatedAt: nowIso
      });

      // ocorr√™ncia pendente (s√≥ visualiza√ß√£o)
      try{
        await addDoc(collection(db, "ft_pendentes"), {
          status: "pendente",
          re,
          nome: colaborador.nome,
          diaOriginal: hoje,
          diaRegistrado: diaSeguinte,
          motivo: ft.motivo,
          supervisor: ft.supervisor,
          posto,
          location,
          createdAt: nowIso,
          updatedAt: nowIso
        });
      }catch{}

      alert("‚úÖ FT registrada! (A entrada foi lan√ßada como dia seguinte para an√°lise interna.)");
      limparForm();
      return;
    }

    // ENTRADA normal
    await addDoc(collection(db, "jornadas"), {
      re,
      nome: colaborador.nome,
      status: "aberta",
      entrada: { ts: nowIso, foto, location, posto },
      updatedAt: nowIso
    });
    alert("ENTRADA registrada com sucesso!");
    limparForm();
    return;
  }

  // demais marca√ß√µes exigem jornada ativa
  if (!jornadaAtiva || !jornadaAtiva.id){
    await atualizarTela();
    return alert("N√£o foi encontrada jornada ativa. Tente novamente.");
  }

  const ref = doc(db, "jornadas", jornadaAtiva.id);
  const payload = {};

  payload[acao] = { ts: nowIso, foto, location, posto };
  payload.updatedAt = nowIso;

  const temEntrada = !!jornadaAtiva?.entrada?.ts;
  const temSaiInt = !!jornadaAtiva?.saida_intervalo?.ts;
  const temRetInt = !!jornadaAtiva?.retorno_intervalo?.ts;
  if (acao === ETAPAS.SAIDA && temEntrada && !temSaiInt && !temRetInt){
    payload.flags = { ...(jornadaAtiva.flags || {}) };
    payload.flags.intrajornada_nao_realizada = true;
    payload.flags.intrajornada_registrado_em = nowIso;
  }

  if (acao === ETAPAS.SAIDA) payload.status = "fechada";
  if (acao === ETAPAS.ENTRADA_HE) payload.status = "he_aberta";
  if (acao === ETAPAS.SAIDA_HE) payload.status = "fechada";

  await setDoc(ref, payload, { merge:true });

  alert((etapaLabels[acao] || acao) + " registrada com sucesso!");
  limparForm();
});
</script>
</body>
</html>
