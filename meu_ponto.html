<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Área do Colaborador - Meu Ponto</title>

<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">

<style>
  body { font-family: 'Montserrat', Arial, sans-serif; background:#f0f0f0; padding:20px; }
  .container{
    max-width:1100px; margin:auto; background:#fff; padding:18px;
    border-radius:12px; box-shadow:0 2px 10px rgba(0,0,0,0.08);
  }
  .logo{ width:180px; display:block; margin:0 auto 10px; }
  h2{ text-align:center; margin:8px 0 12px; }
  .row{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:end; }
  input, select, button{
    padding:10px; border-radius:8px; border:1px solid #ccc;
    font-family:inherit;
  }
  input, select{ min-width:220px; }
  button{ cursor:pointer; background:#1f6feb; color:#fff; border:none; font-weight:700; }
  button.secondary{ background:#6c757d; }
  button:disabled{ opacity:.6; cursor:not-allowed; }
  .info{ text-align:center; margin:10px 0; font-weight:700; }
  .small{ text-align:center; font-size:12px; color:#666; margin-top:6px; }
  table{ width:100%; border-collapse:collapse; margin-top:14px; font-size:12px; }
  th,td{ border:1px solid #ddd; padding:8px; text-align:center; }
  th{ background:#fafafa; }
  .footer{ text-align:center; margin-top:14px; font-size:12px; color:#666; }
  .muted{ color:#999; }
</style>
</head>

<body>
<div class="container">
  <img src="GW.png" class="logo" />
  <h2>Área do Colaborador</h2>

  <!-- LOGIN -->
  <div id="loginBox">
    <div class="row">
      <div>
        <label>RE</label><br>
        <input id="re" placeholder="Digite seu RE" inputmode="numeric" autocomplete="off">
      </div>
      <div>
        <label>Senha (4 primeiros do CPF)</label><br>
        <input id="senha" type="password" placeholder="Ex: 4382" inputmode="numeric" autocomplete="off">
      </div>
      <button id="btnEntrar">Entrar</button>
      <button class="secondary" onclick="voltar()">Voltar ao Registro</button>
    </div>
    <div class="small">A senha é os 4 primeiros dígitos do CPF cadastrado pelo administrador.</div>
  </div>

  <!-- CONTEÚDO -->
  <div id="conteudo" style="display:none;">
    <div class="info" id="infoUser">—</div>

    <div class="row">
      <div>
        <label>Mês</label><br>
        <select id="mes"></select>
      </div>
      <div>
        <label>Ano</label><br>
        <select id="ano"></select>
      </div>

      <button id="btnCarregar">Carregar</button>
      <button id="btnPdf">Exportar PDF</button>
      <button class="secondary" onclick="voltar()">Voltar ao Registro</button>
    </div>

    <div class="small" id="hintMes">
      A jornada pertence ao dia da <b>ENTRADA</b>. Se virar o dia, a saída aparece com <b>(+1)</b>.
    </div>

    <table>
      <thead>
        <tr>
          <th>Data</th>
          <th>Dia</th>
          <th>Entrada</th>
          <th>Saída Intervalo</th>
          <th>Retorno</th>
          <th>Saída</th>
          <th>Entrada HE</th>
          <th>Saída HE</th>
          <th>Posto</th>
          <th>Obs</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>

    <div class="footer">
      Sistema desenvolvido por Gabriel Wandele, todos direitos reservados
    </div>
  </div>
</div>

<!-- jsPDF -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>

async function loadImageAsDataURL(url){
  const res = await fetch(url);
  const blob = await res.blob();
  return await new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onload = () => resolve(r.result);
    r.onerror = reject;
    r.readAsDataURL(blob);
  });
}

function shortObsForPdf(text){
  const t = (text || "").replace(/\s+/g, " ").trim();
  // evita quebrar linha -> mantém 1 página
  const max = 26;
  if (t.length <= max) return t;
  return t.slice(0, max - 1) + "…";
}

function shortPostoForPdf(text){
  const t = (text || "").trim();
  const max = 18;
  if (t.length <= max) return t;
  return t.slice(0, max - 1) + "…";
}
    
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, getDoc, getDocs, collection, query, where } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyD--zpWLbLg5X82oGTyz6SuPFQV0sd7NWc",
  authDomain: "controle-ponto-f539b.firebaseapp.com",
  projectId: "controle-ponto-f539b",
  storageBucket: "controle-ponto-f539b.appspot.com",
  messagingSenderId: "324716100257",
  appId: "1:324716100257:web:32d49a9ab4916182dd4ee0"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const loginBox = document.getElementById("loginBox");
const conteudo = document.getElementById("conteudo");
const infoUser = document.getElementById("infoUser");
const tbody = document.getElementById("tbody");

const reEl = document.getElementById("re");
const senhaEl = document.getElementById("senha");
const btnEntrar = document.getElementById("btnEntrar");

const mesSel = document.getElementById("mes");
const anoSel = document.getElementById("ano");
const btnCarregar = document.getElementById("btnCarregar");
const btnPdf = document.getElementById("btnPdf");

let user = null;          // {re,nome,cpf}
let cacheLocais = [];     // [{nome,lat,lng,raio}]
let jornadasMes = [];     // jornadas do mês (somente as que entrada está no mês)
let linhasMes = [];       // linhas 01..ultimoDia com dados ou vazias

function voltar(){ window.location.href = "index.html"; }
window.voltar = voltar;

function pad2(n){ return String(n).padStart(2,"0"); }
function toDateAny(ts){
  if (!ts) return null;
  if (ts.toDate) return ts.toDate();
  if (ts instanceof Date) return ts;
  return new Date(ts);
}
function ymd(d){
  if (!d || isNaN(d)) return "";
  return d.toISOString().slice(0,10);
}
function hm(d){
  if (!d || isNaN(d)) return "";
  return d.toLocaleTimeString("pt-BR", {hour:"2-digit", minute:"2-digit"});
}
function weekday(d){
  if (!d || isNaN(d)) return "";
  return d.toLocaleDateString("pt-BR", { weekday:"short" });
}
function daysInMonth(year, month1to12){
  return new Date(year, month1to12, 0).getDate(); // mês 1..12
}

// Distância (Haversine) p/ reconhecer local
function haversineMeters(lat1, lon1, lat2, lon2){
  const R = 6371000;
  const toRad = x => x * Math.PI / 180;
  const dLat = toRad(lat2-lat1);
  const dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
function parseLocation(str){
  if (!str) return null;
  const p = str.split(",").map(s=>s.trim());
  if (p.length !== 2) return null;
  const lat = Number(p[0]), lng = Number(p[1]);
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
  return {lat,lng};
}
function getBestLocationFromJornada(j){
  const steps = ["saida_he","entrada_he","saida","retorno_intervalo","saida_intervalo","entrada"];
  for (const s of steps){
    const loc = j?.[s]?.location;
    if (loc) return loc;
  }
  return "";
}
function reconhecerLocal(locationStr){
  const p = parseLocation(locationStr);
  if (!p) return "Não disponível";
  let best = null;
  for (const l of cacheLocais){
    const d = haversineMeters(p.lat,p.lng,l.lat,l.lng);
    if (d <= l.raio){
      if (!best || d < best.d) best = {nome:l.nome, d};
    }
  }
  return best ? best.nome : "Não reconhecido";
}

// Popula selects mês/ano
(function initMonthYear(){
  const now = new Date();
  const y = now.getFullYear();
  for (let m=1;m<=12;m++){
    const opt = document.createElement("option");
    opt.value = String(m);
    opt.textContent = pad2(m);
    if (m === (now.getMonth()+1)) opt.selected = true;
    mesSel.appendChild(opt);
  }
  for (let yy=y-3; yy<=y+1; yy++){
    const opt = document.createElement("option");
    opt.value = String(yy);
    opt.textContent = String(yy);
    if (yy === y) opt.selected = true;
    anoSel.appendChild(opt);
  }
})();

async function carregarLocais(){
  const snap = await getDocs(collection(db, "locais"));
  cacheLocais = snap.docs.map(d => d.data())
    .filter(l => Number.isFinite(l.lat) && Number.isFinite(l.lng) && Number.isFinite(l.raio));
}

async function entrar(){
  const re = reEl.value.trim();
  const senha = senhaEl.value.trim();
  if (!re || !senha) return alert("Digite RE e senha.");

  const ref = doc(db, "colaboradores", re);
  const snap = await getDoc(ref);
  if (!snap.exists()) return alert("RE não cadastrado.");

  const data = snap.data() || {};
  const nome = (data.nome || "").trim();
  const cpf  = (data.cpf  || "").toString().trim();
  const ativo = (data.ativo !== false);

  if (!ativo) return alert("Seu cadastro está INATIVO. Procure o administrador.");
  if (!cpf || cpf.replace(/\D/g,"").length < 4) return alert("CPF não cadastrado corretamente. Procure o administrador.");

  const senhaCorreta = cpf.replace(/\D/g,"").slice(0,4);
  if (senha !== senhaCorreta) return alert("Senha incorreta.");

  user = { re, nome, cpf };

  await carregarLocais();

  infoUser.textContent = `${user.nome} — RE ${user.re}`;
  loginBox.style.display = "none";
  conteudo.style.display = "block";

  await carregar();
}

btnEntrar.addEventListener("click", entrar);
btnCarregar.addEventListener("click", carregar);

async function carregar(){
  if (!user) return;

  const mes = Number(mesSel.value);
  const ano = Number(anoSel.value);

  // pega jornadas do RE e filtra pelo mês/ano da ENTRADA
  const q = query(collection(db, "jornadas"), where("re", "==", user.re));
  const snap = await getDocs(q);
  const jornadas = snap.docs.map(d => ({ id:d.id, ...d.data() }));

  jornadasMes = jornadas.filter(j => {
    const dEnt = toDateAny(j.entrada?.ts);
    if (!dEnt || isNaN(dEnt)) return false;
    return (dEnt.getFullYear() === ano) && ((dEnt.getMonth()+1) === mes);
  }).sort((a,b) => (toDateAny(a.entrada?.ts)||0) - (toDateAny(b.entrada?.ts)||0));

  // monta linhas 01..último dia com vazios
  const last = daysInMonth(ano, mes);
  const mapDia = {}; // dia -> array de jornadas
  for (const j of jornadasMes){
    const dEnt = toDateAny(j.entrada?.ts);
    const dia = dEnt.getDate();
    if (!mapDia[dia]) mapDia[dia] = [];
    mapDia[dia].push(j);
  }

  linhasMes = [];
  for (let dia=1; dia<=last; dia++){
    const dateObj = new Date(ano, mes-1, dia, 12, 0, 0); // meio-dia para evitar bug TZ
    const js = mapDia[dia] || [];
    linhasMes.push({ dia, dateObj, jornadas: js });
  }

  renderTabela();
}

function obsJornada(j){
  const dEnt = toDateAny(j.entrada?.ts);
  const dSai = toDateAny(j.saida?.ts);
  let obs = [];

  if (dEnt && dSai && ymd(dEnt) !== ymd(dSai)) obs.push("Virou o dia");
  if (!j.saida?.ts) obs.push("Sem saída");
  if ((j.saida_intervalo?.ts && !j.retorno_intervalo?.ts) || (!j.saida_intervalo?.ts && j.retorno_intervalo?.ts)) {
    obs.push("Intervalo incompleto");
  }

  const posto = reconhecerLocal(getBestLocationFromJornada(j));
  if (posto === "Não reconhecido") obs.push("Fora do posto");

  return obs.join(" | ");
}

function firstOrEmpty(arr){ return arr && arr.length ? arr[0] : null; }

function renderTabela(){
  tbody.innerHTML = "";

  const mes = Number(mesSel.value);
  const ano = Number(anoSel.value);
  const last = daysInMonth(ano, mes);

  // sempre renderiza 01..last
  for (let i=0; i<linhasMes.length; i++){
    const linha = linhasMes[i];
    const dateObj = linha.dateObj;
    const j1 = firstOrEmpty(linha.jornadas);

    let entrada="", saiInt="", retInt="", saida="", entHe="", saiHe="", posto="", obs="";
    if (j1){
      const dEnt = toDateAny(j1.entrada?.ts);
      const dSai = toDateAny(j1.saida?.ts);

      entrada = hm(toDateAny(j1.entrada?.ts));
      saiInt  = hm(toDateAny(j1.saida_intervalo?.ts));
      retInt  = hm(toDateAny(j1.retorno_intervalo?.ts));
      saida   = hm(dSai) + ((dSai && dEnt && ymd(dSai) !== ymd(dEnt)) ? " (+1)" : "");
      entHe   = hm(toDateAny(j1.entrada_he?.ts));
      saiHe   = hm(toDateAny(j1.saida_he?.ts));
      posto   = reconhecerLocal(getBestLocationFromJornada(j1));
      obs     = obsJornada(j1);

      // se houver mais de 1 jornada no mesmo dia, registra na obs
      if (linha.jornadas.length > 1){
        obs = (obs ? (obs + " | ") : "") + `2+ jornadas no dia (${linha.jornadas.length})`;
      }
    } else {
      // linha vazia
      posto = "";
      obs = "";
    }

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${String(linha.dia).padStart(2,"0")}/${String(mes).padStart(2,"0")}/${ano}</td>
      <td class="${j1 ? "" : "muted"}">${weekday(dateObj)}</td>
      <td>${entrada}</td>
      <td>${saiInt}</td>
      <td>${retInt}</td>
      <td>${saida}</td>
      <td>${entHe}</td>
      <td>${saiHe}</td>
      <td>${posto}</td>
      <td>${obs}</td>
    `;
    tbody.appendChild(tr);
  }
}

btnPdf.addEventListener("click", exportarPdf);

async function exportarPdf(){
  if (!user) return;

  const mes = Number(mesSel.value);
  const ano = Number(anoSel.value);
  const mesTxt = pad2(mes);

  const { jsPDF } = window.jspdf;

  // A4 VERTICAL
  const docPdf = new jsPDF({ orientation:"portrait", unit:"pt", format:"a4" });
  const pageW = docPdf.internal.pageSize.getWidth();
  const pageH = docPdf.internal.pageSize.getHeight();

  // LOGO (GW.png)
  let logoDataUrl = null;
  try {
    logoDataUrl = await loadImageAsDataURL("GW.png");
  } catch {
    // se falhar, segue sem logo
    logoDataUrl = null;
  }

  function buildBody(){
    return linhasMes.map(linha => {
      const j1 = (linha.jornadas && linha.jornadas.length) ? linha.jornadas[0] : null;

      let entrada="", saiInt="", retInt="", saida="", entHe="", saiHe="", posto="", obs="";
      if (j1){
        const dEnt = toDateAny(j1.entrada?.ts);
        const dSai = toDateAny(j1.saida?.ts);

        entrada = hm(toDateAny(j1.entrada?.ts));
        saiInt  = hm(toDateAny(j1.saida_intervalo?.ts));
        retInt  = hm(toDateAny(j1.retorno_intervalo?.ts));
        saida   = hm(dSai) + ((dSai && dEnt && ymd(dSai) !== ymd(dEnt)) ? " (+1)" : "");
        entHe   = hm(toDateAny(j1.entrada_he?.ts));
        saiHe   = hm(toDateAny(j1.saida_he?.ts));

        posto   = shortPostoForPdf(reconhecerLocal(getBestLocationFromJornada(j1)));
        obs     = shortObsForPdf(obsJornada(j1));

        if (linha.jornadas.length > 1){
          const extra = `2+ (${linha.jornadas.length})`;
          obs = shortObsForPdf((obs ? (obs + " | ") : "") + extra);
        }
      }

      return [
        `${String(linha.dia).padStart(2,"0")}/${String(mes).padStart(2,"0")}/${ano}`,
        weekday(linha.dateObj),
        entrada, saiInt, retInt, saida, entHe, saiHe,
        posto,
        obs
      ];
    });
  }

  // Cabeçalhos curtos pra caber na vertical
  const head = [[ "Data","Dia","Ent","Sai Int","Ret","Sai","HE Ent","HE Sai","Posto","Obs" ]];
  const body = buildBody();

  // Vamos tentar renderizar com fontes diferentes até garantir 1 página
  const tries = [
    { font:7, pad:2 },
    { font:6, pad:2 },
    { font:5, pad:1 }
  ];

  for (let i=0;i<tries.length;i++){
    const { font, pad } = tries[i];

    // limpa e recria PDF a cada tentativa
    docPdf.deletePage(1);
    docPdf.addPage("a4","portrait");
    docPdf.setPage(1);

    // topo com logo + título
    const marginX = 30;

    let y = 26;

    if (logoDataUrl){
      // logo pequeno pra não comer altura
      const logoW = 90;
      const logoH = 45;
      docPdf.addImage(logoDataUrl, "PNG", marginX, y, logoW, logoH);
      y += logoH + 6;
    } else {
      y += 30;
    }

    docPdf.setFontSize(12);
    docPdf.text("Espelho de Ponto (Colaborador)", marginX, y);
    y += 14;

    docPdf.setFontSize(9);
    docPdf.text(`Nome: ${user.nome}`, marginX, y); y += 12;
    docPdf.text(`RE: ${user.re}`, marginX, y); y += 12;
    docPdf.text(`Competência: ${mesTxt}/${ano}`, marginX, y); y += 12;

    // tabela
    docPdf.autoTable({
      startY: y + 6,
      head,
      body,
      theme: "grid",
      styles: {
        fontSize: font,
        cellPadding: pad,
        overflow: "hidden",
        valign: "middle",
        halign: "center"
      },
      headStyles: {
        fillColor: [240,240,240],
        textColor: [0,0,0]
      },
      // controla largura por coluna (pra caber em portrait)
      columnStyles: {
        0: { cellWidth: 64 },  // Data
        1: { cellWidth: 34 },  // Dia
        2: { cellWidth: 34 },  // Ent
        3: { cellWidth: 40 },  // Sai Int
        4: { cellWidth: 34 },  // Ret
        5: { cellWidth: 38 },  // Sai
        6: { cellWidth: 38 },  // HE Ent
        7: { cellWidth: 38 },  // HE Sai
        8: { cellWidth: 70 },  // Posto
        9: { cellWidth: 70 }   // Obs
      },
      margin: { left: marginX, right: marginX, top: 0, bottom: 18 },
      pageBreak: "avoid"
    });

    // garante 1 página
    if (docPdf.getNumberOfPages() === 1){
      // rodapé discreto
      docPdf.setFontSize(8);
      docPdf.text(
        "Sistema desenvolvido por Gabriel Wandele, todos direitos reservados",
        marginX,
        pageH - 10
      );

      docPdf.save(`espelho_${user.re}_${mesTxt}-${ano}.pdf`);
      return;
    }
  }

  // Se ainda assim gerar mais de 1 página (raríssimo), avisa
  alert("Não foi possível gerar em 1 página. Reduza observações ou simplifique colunas.");
}

    return [
      `${String(linha.dia).padStart(2,"0")}/${String(mes).padStart(2,"0")}/${ano}`,
      weekday(linha.dateObj),
      entrada, saiInt, retInt, saida, entHe, saiHe, posto, obs
    ];
  });

  docPdf.autoTable({
    startY: 140,
    head,
    body,
    styles: { fontSize: 8, cellPadding: 4 },
    headStyles: { fillColor: [240,240,240], textColor: [0,0,0] }
  });

  docPdf.save(`espelho_${user.re}_${mesTxt}-${ano}.pdf`);
}
</script>

</body>
</html>
